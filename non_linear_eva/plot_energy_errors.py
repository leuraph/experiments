import argparse
from pathlib import Path
from tqdm import tqdm
from load_save_dumps import load_dump
from p1afempy.io_helpers import read_elements, read_coordinates
import numpy as np
from problems import get_problem
import matplotlib.pyplot as plt
from compute_energies import compute_energy


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--reference-solution", type=str, required=True)
    parser.add_argument("--reference-mesh", type=str, required=True)
    parser.add_argument("--problem", type=int, required=True)
    parser.add_argument("--path", type=str, required=True)
    args = parser.parse_args()

    output_path = Path('plots') / Path(f'{args.path}.pdf').name

    problem = get_problem(number=args.problem)

    path_to_reference_solution = Path(args.reference_solution)
    path_to_results = Path(args.path)

    path_to_reference_mesh = Path(args.reference_mesh)
    path_to_reference_coordinates = path_to_reference_mesh / Path("coordinates.dat")
    path_to_reference_elements = path_to_reference_mesh / Path("elements.dat")

    reference_coordinates = read_coordinates(
        path_to_coordinates=path_to_reference_coordinates)
    # we shift the indices by +1 because the reference mesh
    # was generated by MATLAB code
    reference_elements = read_elements(
        path_to_elements=path_to_reference_elements, shift_indices=True)
    reference_solution =load_dump(path_to_dump=path_to_reference_solution)

    reference_energy = compute_energy(
        problem=problem,
        elements=reference_elements,
        coordinates=reference_coordinates,
        current_iterate=reference_solution)

    energies =[]
    criteria_resolved = []
    n_dofs = []

    for path_to_n_dofs in tqdm(list(path_to_results.iterdir())):
        if not path_to_n_dofs.is_dir():
            continue 
        n_dof = int(path_to_n_dofs.name)
        n_dofs.append(n_dof)

        current_energy = load_dump(
            path_to_dump=path_to_n_dofs / 'energy.pkl')
        
        criterion_resolved = load_dump(
            path_to_dump=path_to_n_dofs / 'criterion_resolved.pkl')
        
        energies.append(current_energy)
        criteria_resolved.append(criterion_resolved)

    # converting lists to numpy arrays
    energies = np.array(energies)
    n_dofs = np.array(n_dofs)
    criteria_resolved = np.array(criteria_resolved)
    
    # sorting corresponding to number of degrees of freedom
    sort_n_dof = n_dofs.argsort()
    n_dofs = n_dofs[sort_n_dof]
    energies = energies[sort_n_dof]
    criteria_resolved = criteria_resolved[sort_n_dof]

    energy_differences = energies - reference_energy
    if np.any(energy_differences < 0.0):
        raise RuntimeError(
            "None of the energy differences should be negative!" \
            "This probably means that the reference mesh was too " \
            "coarse or the reference solution too rough"
        )

    # settinng plot params
    # --------------------

    plt.rcParams["mathtext.fontset"] = "cm"
    plt.rcParams['xtick.labelsize'] = 16
    plt.rcParams['ytick.labelsize'] = 16
    plt.rcParams['axes.labelsize'] = 20
    plt.rcParams['axes.titlesize'] = 12
    plt.rcParams['legend.fontsize'] = 16

    fig, ax = plt.subplots()
    ax.set_xlabel(r'$n_{\text{DOF}}$')
    ax.set_ylabel(r'$E(\tilde u) - E(u)$')
    ax.grid(True)

    # plot all points connected by a dotted black line
    ax.loglog(
        n_dofs,
        energy_differences,
        linestyle=':',
        color='black',
        zorder=1
    )
    # plot resolved points (blue) and non-resolved points (red)
    ax.scatter(
        n_dofs[criteria_resolved],
        energy_differences[criteria_resolved],
        color='blue',
        label='resolved',
        zorder=2
    )
    ax.scatter(
        n_dofs[np.logical_not(criteria_resolved)],
        energy_differences[np.logical_not(criteria_resolved)],
        color='red',
        label='not resolved',
        zorder=2
    )
    ax.legend(loc='best')

    fig.savefig(output_path, dpi=300, bbox_inches="tight")


if __name__ == '__main__':
    main()


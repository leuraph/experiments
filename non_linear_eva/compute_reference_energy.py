import argparse
from pathlib import Path
from tqdm import tqdm
from load_save_dumps import dump_object, load_dump
import numpy as np
from scipy.sparse import csr_matrix
from p1afempy.solvers import get_stiffness_matrix, get_right_hand_side, \
    integrate_composition_nonlinear_with_fem, get_mass_matrix, get_general_stiffness_matrix
from p1afempy.data_structures import ElementsType, CoordinatesType
from triangle_cubature.cubature_rule import CubatureRuleEnum
from problems import get_problem, Problem
from p1afempy.io_helpers import read_coordinates, read_elements

def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--problem", type=int, required=True)
    parser.add_argument("--reference-mesh", type=str, required=True)
    parser.add_argument("--reference-solution", type=str, required=True)
    args = parser.parse_args()

    problem = get_problem(number=args.problem)

    path_to_ref_solution = Path(args.reference_solution)
    path_to_ref_mesh = Path(args.reference_mesh)


    path_to_reference_coordinates = path_to_ref_mesh / Path("coordinates.dat")
    path_to_reference_elements = path_to_ref_mesh / Path("elements.dat")

    reference_coordinates = read_coordinates(
        path_to_coordinates=path_to_reference_coordinates)
    # we shift the indices by +1 because the reference mesh
    # was generated by MATLAB code
    reference_elements = read_elements(
        path_to_elements=path_to_reference_elements, shift_indices=True)
    reference_solution =load_dump(path_to_dump=path_to_ref_solution)

    print(f'computing reference energy for problem {args.problem}...')

    reference_energy = compute_energy(
        problem=problem,
        elements=reference_elements,
        coordinates=reference_coordinates,
        current_iterate=reference_solution)
    
    print(f'reference energy is E_ref = {reference_energy}')

    path_to_reference_energy = (
        Path('reference_energies') / 
        Path(f'{path_to_ref_solution.name}.pkl'))

    dump_object(
        obj=reference_energy,
        path_to_file=path_to_reference_energy
    )


def compute_energy(
        problem: Problem,
        elements: ElementsType,
        coordinates: CoordinatesType,
        current_iterate: np.ndarray
        ) -> float:
    """
    given a problem, computes the energy
    E(u) := 1/2 \int <A(x) nabla u(x), nabla u(x)> + int Phi(u) - int fu
    """
    stiffness_matrix = csr_matrix(
        get_general_stiffness_matrix(
            elements=elements,
            coordinates=coordinates,
            a_11=problem.a_11,
            a_12=problem.a_12,
            a_21=problem.a_21,
            a_22=problem.a_22,
            cubature_rule=CubatureRuleEnum.DAYTAYLOR))
    right_hand_side_vector = get_right_hand_side(
        coordinates=coordinates,
        elements=elements,
        f=problem.f,
        cubature_rule=CubatureRuleEnum.DAYTAYLOR)
    energy = (
            0.5 * current_iterate.dot(stiffness_matrix.dot(current_iterate))
            +
            integrate_composition_nonlinear_with_fem(
                f=problem.Phi,
                u=current_iterate,
                coordinates=coordinates,
                elements=elements,
                cubature_rule=CubatureRuleEnum.DAYTAYLOR)
            -
            right_hand_side_vector.dot(current_iterate)
        )
    return energy


if __name__ == '__main__':
    main()

